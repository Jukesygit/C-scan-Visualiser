<!DOCTYPE html>
<html lang="en" class="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phased Array C-Scan Visualizer - Optimized</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .file-input-button {
            transition: background-color 0.2s, box-shadow 0.2s;
        }
        .file-input-button:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .progress-bar-inner {
            transition: width 0.3s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200">

    <div class="container mx-auto p-4 md:p-8">
        <!-- Header -->
        <header class="bg-white dark:bg-gray-800 shadow-md rounded-xl p-6 mb-8 flex justify-between items-center">
            <div>
                <h1 class="text-3xl font-bold text-gray-900 dark:text-white">Phased Array C-Scan Visualizer</h1>
                <p class="mt-2 text-gray-600 dark:text-gray-400">Upload a C-Scan data file (.txt or .csv) to generate an interactive corrosion heatmap.</p>
            </div>
            <button id="theme-toggle" class="p-2 rounded-full text-gray-500 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 focus:ring-offset-gray-100 dark:focus:ring-offset-gray-800">
                <svg id="sun-icon" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                </svg>
                <svg id="moon-icon" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
                </svg>
            </button>
        </header>

        <!-- Main Content -->
        <main class="bg-white dark:bg-gray-800 shadow-md rounded-xl p-6">
            <!-- Upload Section -->
            <div id="upload-section" class="text-center border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-8 md:p-12">
                <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48" aria-hidden="true">
                    <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                </svg>
                <h2 class="mt-4 text-xl font-semibold text-gray-900 dark:text-white">Upload C-Scan file(s)</h2>
                <p class="mt-2 text-sm text-gray-500 dark:text-gray-400">Drag and drop or click to select one or more files.</p>
                <input type="file" id="file-input" class="hidden" accept=".txt,.csv" multiple>
                <button id="upload-button" class="mt-6 file-input-button bg-blue-600 text-white font-semibold py-2 px-6 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                    Select Files
                </button>
            </div>

            <!-- Status/Error Messages -->
            <div id="status-message" class="hidden mt-4 text-center p-4 rounded-lg"></div>
            
            <!-- Progress Bar -->
            <div id="progress-container" class="hidden mt-4 w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5">
                <div id="progress-bar" class="progress-bar-inner bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
            </div>

            <!-- File List and Composite Section -->
            <div id="file-management-section" class="hidden mt-8 p-4 bg-gray-50 dark:bg-gray-700/50 rounded-lg shadow-inner">
                <div class="flex flex-wrap justify-between items-center border-b border-gray-200 dark:border-gray-600 pb-2 mb-4">
                    <h3 class="text-lg font-semibold text-gray-900 dark:text-white">Processed Files</h3>
                    <div class="flex gap-2 mt-2 md:mt-0">
                        <button id="composite-button" class="file-input-button bg-green-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500">
                            Generate Composite
                        </button>
                        <button id="export-button" class="file-input-button bg-purple-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 hidden">
                            Export Image
                        </button>
                        <button id="export-clean-button" class="file-input-button bg-teal-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-teal-500 hidden">
                            Export Heatmap Only
                        </button>
                    </div>
                </div>
                <div id="file-list" class="text-sm text-gray-700 dark:text-gray-300">
                    <!-- File list will be injected here -->
                </div>
            </div>

            <!-- Controls Section -->
            <div id="controls-section" class="hidden mt-8 p-4 bg-gray-50 dark:bg-gray-700/50 rounded-lg shadow-inner">
                <h3 class="text-lg font-semibold border-b border-gray-200 dark:border-gray-600 pb-2 mb-4 text-gray-900 dark:text-white">Display Controls</h3>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
                    <div>
                        <label for="min-thickness" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Min Thickness (mm)</label>
                        <input type="number" id="min-thickness" step="0.1" class="mt-1 block w-full rounded-md border-gray-300 dark:border-gray-600 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm bg-white dark:bg-gray-700 text-gray-900 dark:text-white">
                    </div>
                    <div>
                        <label for="max-thickness" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Max Thickness (mm)</label>
                        <input type="number" id="max-thickness" step="0.1" class="mt-1 block w-full rounded-md border-gray-300 dark:border-gray-600 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm bg-white dark:bg-gray-700 text-gray-900 dark:text-white">
                    </div>
                    <button id="update-button" class="file-input-button bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 w-full md:w-auto">
                        Update View
                    </button>
                </div>
            </div>

            <!-- Visualization Section -->
            <div id="visualization-section" class="hidden mt-8 w-full h-[600px] md:h-[800px]">
                <div id="plot-container" class="w-full h-full"></div>
            </div>
            
            <!-- Metadata Section -->
            <div id="metadata-section" class="hidden mt-8 p-4 bg-gray-50 dark:bg-gray-700/50 rounded-lg shadow-inner">
                <h3 class="text-lg font-semibold border-b border-gray-200 dark:border-gray-600 pb-2 mb-4 text-gray-900 dark:text-white">Scan Metadata</h3>
                <div id="metadata-content" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 text-sm">
                    <!-- Metadata will be injected here -->
                </div>
            </div>
        </main>
    </div>

    <script>
        const uploadButton = document.getElementById('upload-button');
        const fileInput = document.getElementById('file-input');
        const uploadSection = document.getElementById('upload-section');
        const statusMessage = document.getElementById('status-message');
        const visualizationSection = document.getElementById('visualization-section');
        const plotContainer = document.getElementById('plot-container');
        const metadataSection = document.getElementById('metadata-section');
        const metadataContent = document.getElementById('metadata-content');
        const controlsSection = document.getElementById('controls-section');
        const minThicknessInput = document.getElementById('min-thickness');
        const maxThicknessInput = document.getElementById('max-thickness');
        const updateButton = document.getElementById('update-button');
        const fileManagementSection = document.getElementById('file-management-section');
        const fileListContainer = document.getElementById('file-list');
        const compositeButton = document.getElementById('composite-button');
        const exportButton = document.getElementById('export-button');
        const exportCleanButton = document.getElementById('export-clean-button');
        const progressContainer = document.getElementById('progress-container');
        const progressBar = document.getElementById('progress-bar');
        const themeToggleBtn = document.getElementById('theme-toggle');
        const sunIcon = document.getElementById('sun-icon');
        const moonIcon = document.getElementById('moon-icon');

        let processedScans = [];
        let currentScanData = null;
        let compositeWorker = null;
        let isShowingComposite = false;
        
        const customColorscale = [
            [0.0, 'rgb(127, 0, 0)'],   // Darkest Red
            [0.125, 'rgb(255, 0, 0)'],  // Red
            [0.25, 'rgb(255, 127, 0)'], // Orange
            [0.375, 'rgb(255, 255, 0)'],// Yellow
            [0.5, 'rgb(127, 255, 127)'],// Pale Green
            [0.625, 'rgb(0, 255, 255)'],// Cyan
            [0.75, 'rgb(0, 0, 255)'],   // Blue
            [0.875, 'rgb(0, 0, 191)'],  // Dark Blue
            [1.0, 'rgb(0, 0, 127)']    // Darkest Blue
        ];

        // --- THEME SWITCHER LOGIC ---
        function applyTheme(theme) {
            if (theme === 'dark') {
                document.documentElement.classList.add('dark');
                localStorage.setItem('theme', 'dark');
                sunIcon.classList.remove('hidden');
                moonIcon.classList.add('hidden');
            } else {
                document.documentElement.classList.remove('dark');
                localStorage.setItem('theme', 'light');
                sunIcon.classList.add('hidden');
                moonIcon.classList.remove('hidden');
            }
            if (currentScanData) {
                updatePlot();
            }
        }

        themeToggleBtn.addEventListener('click', () => {
            const currentTheme = localStorage.getItem('theme') || 'light';
            applyTheme(currentTheme === 'light' ? 'dark' : 'light');
        });
        
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        if (savedTheme) {
            applyTheme(savedTheme);
        } else if (prefersDark) {
            applyTheme('dark');
        } else {
            applyTheme('light');
        }
        // --- END THEME SWITCHER LOGIC ---


        uploadButton.addEventListener('click', () => fileInput.click());

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadSection.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        uploadSection.addEventListener('dragenter', () => uploadSection.classList.add('border-blue-500', 'bg-blue-50', 'dark:bg-blue-900/50'), false);
        uploadSection.addEventListener('dragleave', () => uploadSection.classList.remove('border-blue-500', 'bg-blue-50', 'dark:bg-blue-900/50'), false);
        uploadSection.addEventListener('drop', handleDrop, false);

        fileInput.addEventListener('change', (event) => {
            const files = event.target.files;
            if (files.length > 0) handleFiles(files);
        });

        function handleDrop(e) {
            uploadSection.classList.remove('border-blue-500', 'bg-blue-50', 'dark:bg-blue-900/50');
            const dt = e.dataTransfer;
            if (dt.files.length > 0) handleFiles(dt.files);
        }
        
        function showStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.className = `mt-4 text-center p-4 rounded-lg ${isError ? 'bg-red-100 text-red-700 dark:bg-red-900/50 dark:text-red-300' : 'bg-blue-100 text-blue-700 dark:bg-blue-900/50 dark:text-blue-300'}`;
            statusMessage.classList.remove('hidden');
        }

        async function handleFiles(files) {
            showStatus(`Processing ${files.length} file(s)...`, false);
            [visualizationSection, metadataSection, controlsSection, fileManagementSection].forEach(el => el.classList.add('hidden'));
            [exportButton, exportCleanButton].forEach(btn => btn.classList.add('hidden'));
            
            processedScans = [];
            isShowingComposite = false;
            
            for (const file of files) {
                try {
                    const parsedData = parseCScanFile(await file.text());
                    parsedData.fileName = file.name;
                    processedScans.push(parsedData);
                } catch (error) {
                    console.error(`Error processing file ${file.name}:`, error);
                    showStatus(`Error processing ${file.name}: ${error.message}`, true);
                    return;
                }
            }

            if (processedScans.length > 0) {
                currentScanData = processedScans[0];
                renderPlot(currentScanData);
                renderMetadata(currentScanData.metadata);
                renderFileList();
                showStatus(`${processedScans.length} file(s) processed successfully.`, false);
                uploadSection.classList.add('hidden');
                fileManagementSection.classList.remove('hidden');
                controlsSection.classList.remove('hidden');
            }
        }

        function parseCScanFile(content) {
            const lines = content.split(/\r?\n/);
            const metadata = {};
            let dataStartIndex = -1;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.startsWith('mm')) {
                    dataStartIndex = i;
                    break;
                }
                const parts = line.split('=').map(p => p.trim());
                if (parts.length === 2) {
                    metadata[parts[0]] = isNaN(parseFloat(parts[1])) ? parts[1] : parseFloat(parts[1]);
                }
            }
            
            if (dataStartIndex === -1) throw new Error('Could not find data matrix header (line starting with "mm").');

            const xCoords = lines[dataStartIndex].split('\t').slice(1).map(parseFloat);
            const yCoords = [];
            const tempThicknessValues = [];
            
            for (let i = dataStartIndex + 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                const rowValues = line.split('\t');
                const yValue = parseFloat(rowValues[0]);
                if (isNaN(yValue)) continue;
                yCoords.push(yValue);
                tempThicknessValues.push(rowValues.slice(1).map(val => (val === 'ND' || val.trim() === '') ? NaN : parseFloat(val)));
            }

            if (xCoords.length === 0 || yCoords.length === 0 || tempThicknessValues.length === 0) throw new Error('Failed to parse data matrix.');
            
            const flatThicknessValues = new Float32Array(tempThicknessValues.length * xCoords.length);
            tempThicknessValues.forEach((row, i) => flatThicknessValues.set(row, i * xCoords.length));

            return { metadata, x_coords: xCoords, y_coords: yCoords, thickness_values_flat: flatThicknessValues, rows: yCoords.length, cols: xCoords.length };
        }

        function findMinMax(data) {
            let min = Infinity, max = -Infinity;
            for (const val of data) {
                if (!isNaN(val)) {
                    if (val < min) min = val;
                    if (val > max) max = val;
                }
            }
            return { min: min === Infinity ? 0 : min, max: max === -Infinity ? 0 : max };
        }
        
        function reconstructMatrix(flatData, rows, cols) {
            const matrix = [];
            for (let i = 0; i < rows; i++) {
                const row = new Array(cols);
                for (let j = 0; j < cols; j++) {
                    const val = flatData[i * cols + j];
                    row[j] = isNaN(val) ? null : val;
                }
                matrix.push(row);
            }
            return matrix;
        }

        function renderPlot(data, isComposite = false) {
            const metaMin = data.metadata['Min Thickness (mm)'];
            const metaMax = data.metadata['Max Thickness (mm)'];

            let matrix = (isComposite && data.compositeMatrix) ? data.compositeMatrix : reconstructMatrix(data.thickness_values_flat, data.rows, data.cols);
            
            if (!isComposite && metaMin !== undefined && metaMax !== undefined) {
                minThicknessInput.value = parseFloat(metaMin).toFixed(2);
                maxThicknessInput.value = parseFloat(metaMax).toFixed(2);
            } else if (isComposite) {
                const stdMinMax = getStandardizedMinMax();
                if (stdMinMax) {
                    minThicknessInput.value = stdMinMax.min.toFixed(2);
                    maxThicknessInput.value = stdMinMax.max.toFixed(2);
                } else {
                    const { min, max } = findMinMax(data.thickness_values_flat || matrix.flat());
                    minThicknessInput.value = min.toFixed(2);
                    maxThicknessInput.value = max.toFixed(2);
                }
            } else {
                const { min, max } = findMinMax(data.thickness_values_flat);
                minThicknessInput.value = min.toFixed(2);
                maxThicknessInput.value = max.toFixed(2);
            }

            updatePlot(matrix, data.x_coords, data.y_coords, isComposite);
        }

        function updatePlot(matrix, xCoords, yCoords, isComposite) {
            if (!matrix) {
                if (!currentScanData) return;
                isComposite = isShowingComposite;
                if (isShowingComposite && currentScanData.compositeMatrix) {
                    matrix = currentScanData.compositeMatrix;
                    xCoords = currentScanData.x_coords;
                    yCoords = currentScanData.y_coords;
                } else if (currentScanData.thickness_values_flat) {
                    matrix = reconstructMatrix(currentScanData.thickness_values_flat, currentScanData.rows, currentScanData.cols);
                    xCoords = currentScanData.x_coords;
                    yCoords = currentScanData.y_coords;
                } else return;
            }

            const zmin = parseFloat(minThicknessInput.value) || null;
            const zmax = parseFloat(maxThicknessInput.value) || null;

            const plotData = [{ x: xCoords, y: yCoords, z: matrix, type: 'heatmap', colorscale: customColorscale, zsmooth: 'best', connectgaps: false, zmin, zmax, colorbar: { title: 'Thickness (mm)', titleside: 'right' }, hovertemplate: 'X: %{x:.2f} mm<br>Y: %{y:.2f} mm<br>Thickness: %{z:.2f} mm<extra></extra>' }];
            const title = isShowingComposite ? 'Composite Corrosion Map' : 'Corrosion Heatmap';
            const layout = { title: { text: title, font: { size: 20 } }, xaxis: { title: 'Scan Axis (mm)', scaleanchor: "y", scaleratio: 1.0, zeroline: false }, yaxis: { title: 'Index Axis (mm)', zeroline: false }, autosize: true, margin: { l: 60, r: 60, t: 60, b: 60 } };
            
            if (localStorage.getItem('theme') === 'dark') {
                layout.template = 'plotly_dark';
                layout.paper_bgcolor = 'rgb(31, 41, 55)'; // Tailwind gray-800
                layout.plot_bgcolor = 'rgb(31, 41, 55)';
            }
            
            const config = { responsive: true, displaylogo: false, modeBarButtonsToAdd: ['hoverclosest', 'hovercompare']};

            Plotly.react(plotContainer, plotData, layout, config);
            visualizationSection.classList.remove('hidden');
            
            [exportButton, exportCleanButton].forEach(btn => btn.classList.remove('hidden'));
        }
        
        updateButton.addEventListener('click', () => updatePlot());
        compositeButton.addEventListener('click', generateComposite);
        exportButton.addEventListener('click', exportImage);
        exportCleanButton.addEventListener('click', exportCleanImage);

        function renderFileList() {
            fileListContainer.innerHTML = '';
            processedScans.forEach((scan) => {
                const fileElement = document.createElement('div');
                fileElement.className = 'p-2 mt-2 rounded cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors';
                if (!isShowingComposite && scan === currentScanData) {
                    fileElement.classList.add('bg-blue-100', 'dark:bg-blue-900/50', 'font-semibold');
                }
                fileElement.textContent = scan.fileName;
                fileElement.onclick = () => {
                    currentScanData = scan;
                    isShowingComposite = false;
                    renderPlot(currentScanData);
                    renderMetadata(currentScanData.metadata);
                    renderFileList();
                };
                fileListContainer.appendChild(fileElement);
            });
        }
        
        function getCompositeWorker() {
            const workerCode = `self.onmessage = e => {
                const scans = e.data; let gMinX=Infinity,gMaxX=-Infinity,gMinY=Infinity,gMaxY=-Infinity;
                scans.forEach(s => { const minX=Math.min(...s.x_coords),maxX=Math.max(...s.x_coords),minY=Math.min(...s.y_coords),maxY=Math.max(...s.y_coords); if(minX<gMinX)gMinX=minX; if(maxX>gMaxX)gMaxX=maxX; if(minY<gMinY)gMinY=minY; if(maxY>gMaxY)gMaxY=maxY; });
                let minSp=Infinity; scans.forEach(s => { if(s.x_coords.length>1){const sp=Math.abs(s.x_coords[1]-s.x_coords[0]); if(sp>0&&sp<minSp)minSp=sp;} if(s.y_coords.length>1){const sp=Math.abs(s.y_coords[1]-s.y_coords[0]); if(sp>0&&sp<minSp)minSp=sp;} });
                const res=minSp!==Infinity?minSp:1.0, gW=Math.ceil((gMaxX-gMinX)/res)+1, gH=Math.ceil((gMaxY-gMinY)/res)+1;
                const compG=new Float32Array(gH*gW).fill(0), wG=new Float32Array(gH*gW).fill(0);
                scans.forEach((s,s_idx) => {
                    for(let i=0;i<s.rows;i++){ for(let j=0;j<s.cols;j++){ const val=s.thickness_values_flat[i*s.cols+j]; if(!isNaN(val)&&val>0){ const x=s.x_coords[j], y=s.y_coords[i], gX=Math.round((x-gMinX)/res), gY=Math.round((y-gMinY)/res); if(gX>=0&&gX<gW&&gY>=0&&gY<gH){ const idx=gY*gW+gX; compG[idx]+=val; wG[idx]+=1; }}}}
                    self.postMessage({type:'progress',current:s_idx+1,total:scans.length});
                });
                const mat=[], xC=Array.from({length:gW},(_,i)=>gMinX+i*res), yC=Array.from({length:gH},(_,i)=>gMinY+i*res), flatD=new Float32Array(gH*gW);
                for(let i=0;i<gH;i++){ const row=[]; for(let j=0;j<gW;j++){ const idx=i*gW+j; let val=null; if(wG[idx]>0)val=compG[idx]/wG[idx]; row.push(val); flatD[idx]=isNaN(val)?NaN:val; } mat.push(row); }
                self.postMessage({type:'result',matrix:mat,xCoords:xC,yCoords:yC,flatData:flatD});
            }`;
            return new Worker(URL.createObjectURL(new Blob([workerCode], { type: 'application/javascript' })));
        }

        function getStandardizedMinMax() {
            const counts = new Map();
            processedScans.forEach(scan => {
                const key = `${scan.metadata['Min Thickness (mm)']}|${scan.metadata['Max Thickness (mm)']}`;
                if (key.includes('undefined')) return;
                counts.set(key, (counts.get(key) || 0) + 1);
            });
            if (counts.size === 0) return null;
            const mostCommonKey = [...counts.entries()].reduce((a, e) => e[1] > a[1] ? e : a)[0];
            const [min, max] = mostCommonKey.split('|').map(parseFloat);
            return { min, max };
        }

        function generateComposite() {
            if (processedScans.length < 2) return showStatus("Please upload at least two files.", true);

            showStatus("Generating composite heatmap...", false);
            progressContainer.classList.remove('hidden');
            progressBar.style.width = '0%';
            compositeButton.disabled = true;
            compositeButton.textContent = "Processing...";

            if (compositeWorker) compositeWorker.terminate();
            compositeWorker = getCompositeWorker();

            compositeWorker.onmessage = function({data}) {
                if (data.type === 'progress') {
                    progressBar.style.width = `${(data.current / data.total) * 100}%`;
                } else if (data.type === 'result') {
                    const { matrix, xCoords, yCoords, flatData } = data;
                    currentScanData = { metadata: { 'Type': 'Composite', 'Source Files': processedScans.length }, compositeMatrix: matrix, x_coords: xCoords, y_coords: yCoords, thickness_values_flat: flatData, rows: yCoords.length, cols: xCoords.length, isComposite: true };
                    isShowingComposite = true;
                    renderPlot(currentScanData, true);
                    renderMetadata(currentScanData.metadata);
                    renderFileList();
                    showStatus("Composite generated successfully.", false);
                    progressContainer.classList.add('hidden');
                    compositeButton.disabled = false;
                    compositeButton.textContent = "Generate Composite";
                    compositeWorker.terminate();
                    compositeWorker = null;
                }
            };

            compositeWorker.onerror = e => {
                showStatus(`Error during composite generation: ${e.message}`, true);
                progressContainer.classList.add('hidden');
                compositeButton.disabled = false; compositeButton.textContent = "Generate Composite";
                if (compositeWorker) compositeWorker.terminate();
            };
            compositeWorker.postMessage(processedScans);
        }

        function exportImage() {
            if (!currentScanData) return;
            const filename = (isShowingComposite ? 'composite' : currentScanData.fileName.split('.')[0]) + `_cscan-full.png`;
            Plotly.downloadImage(plotContainer, { format: 'png', width: 1920, height: 1080, scale: 2, filename }).then(() => showStatus("Image exported!", false));
        }

        async function exportCleanImage() {
            if (!currentScanData) return showStatus("No data to export.", true);
            showStatus("Preparing clean export...", false);

            const originalData = JSON.parse(JSON.stringify(plotContainer.data));
            const originalLayout = JSON.parse(JSON.stringify(plotContainer.layout));
            const cleanLayout = { ...originalLayout, title: null, 'xaxis.visible': false, 'yaxis.visible': false, margin: { l: 0, r: 0, t: 0, b: 0 } };
            const cleanData = JSON.parse(JSON.stringify(originalData));
            if (cleanData[0]) cleanData[0].showscale = false;

            try {
                await Plotly.react(plotContainer, cleanData, cleanLayout, plotContainer._context);
                const filename = (isShowingComposite ? 'composite' : currentScanData.fileName.split('.')[0]) + `_cscan-heatmap.png`;
                await Plotly.downloadImage(plotContainer, { format: 'png', width: 1920, height: 1080, scale: 1, filename });
                showStatus("Clean heatmap exported!", false);
            } catch (e) {
                showStatus("Failed to export clean heatmap.", true);
            } finally {
                await Plotly.react(plotContainer, originalData, originalLayout, plotContainer._context);
            }
        }

        function renderMetadata(metadata) {
            metadataContent.innerHTML = '';
            for (const key in metadata) {
                const div = document.createElement('div');
                div.className = 'p-2 bg-white dark:bg-gray-800 rounded shadow-sm';
                div.innerHTML = `<span class="font-semibold text-gray-600 dark:text-gray-400">${key}:</span> <span class="text-gray-800 dark:text-gray-200">${metadata[key]}</span>`;
                metadataContent.appendChild(div);
            }
            metadataSection.classList.remove('hidden');
        }
    </script>
</body>
</html>

